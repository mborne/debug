// code generated by Cursor

import { readFileSync } from 'fs';
import { buffers } from '../memoryLeakData.js';
import { getStressCpuRunning } from '../stressState.js';

/**
 * Reads container memory from cgroup (same metric as docker stats).
 * Returns bytes or null if not in a container or unavailable.
 */
function getCgroupMemoryBytes() {
    try {
        // cgroup v2 (Docker with private cgroup ns): /sys/fs/cgroup is the container root
        const v2 = readFileSync('/sys/fs/cgroup/memory.current', 'utf8');
        const bytes = parseInt(v2.trim(), 10);
        return Number.isNaN(bytes) ? null : bytes;
    } catch {
        try {
            // cgroup v1: use path from /proc/self/cgroup
            const cgroup = readFileSync('/proc/self/cgroup', 'utf8');
            const memoryLine = cgroup.split('\n').find((l) => l.startsWith('2:memory:') || l.startsWith('1:memory:'));
            if (!memoryLine) return null;
            const path = memoryLine.split(':')[2] || '/';
            const usagePath = `/sys/fs/cgroup/memory${path}/memory.usage_in_bytes`;
            const v1 = readFileSync(usagePath, 'utf8');
            const bytes = parseInt(v1.trim(), 10);
            return Number.isNaN(bytes) ? null : bytes;
        } catch {
            return null;
        }
    }
}

/**
 * Provides started_at, memory (process stats + cgroup when in container), leaked_buffers_count and stress_cpu.
 */
export default function stats(req, res) {
    const startedAt = new Date(Date.now() - process.uptime() * 1000).toISOString();
    const mem = process.memoryUsage();
    const cgroupBytes = getCgroupMemoryBytes();

    res.send({
        started_at: startedAt,
        memory: {
            rss: mem.rss,
            heapUsed: mem.heapUsed,
            /** Container memory (cgroup), same as docker stats; only set when running in a container */
            container: cgroupBytes ?? undefined
        },
        leaked_buffers_count: buffers.length,
        stress_cpu: getStressCpuRunning()
    });
}
